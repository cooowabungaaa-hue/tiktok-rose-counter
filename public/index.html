<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TikTok Live Rose Counter</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #ff0050;
            --secondary: #00f2ea;
            --bg: #0a0a0b;
            --card-bg: #16171d;
            --text: #ffffff;
            --text-dim: #a0a0a5;
            --rose: #ff4d6d;
        }

        body {
            margin: 0;
            font-family: 'Orbitron', sans-serif;
            /* Stylish default */
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            margin: 10px 0 0.5rem 0;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 0, 80, 0.3);
        }

        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .controls-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .input-group {
            background: var(--card-bg);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            flex: 1;
        }

        input {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 16px;
            color: white;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: var(--primary);
        }

        button {
            padding: 12px 24px;
            background: var(--primary);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        button.secondary-btn {
            background: var(--secondary);
            color: var(--bg);
        }

        button:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }

        button:active {
            transform: translateY(0);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-offline {
            background: #444;
            color: #ccc;
        }

        .status-online {
            background: #4caf50;
            color: white;
            animation: pulse 2s infinite;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: bold;
        }

        .unique-value {
            color: var(--secondary);
        }

        .total-value {
            color: var(--rose);
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }

        .combined-stat {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            position: relative;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-divider {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            color: var(--text-dim);
            font-weight: bold;
            transform: translateY(10px);
            /* Align with numbers visually */
        }

        .feed-panel {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            /* max-height: 550px; Removed fixed height */
            height: calc(100vh - 240px);
            /* Fill remaining space */
            min-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .feed-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .rose-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            animation: slideIn 0.3s ease-out;
        }

        .unique-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--primary);
        }

        .unique-item .avatar {
            border-color: var(--secondary);
        }

        .user-info {
            flex: 1;
        }

        .username {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .user-id {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .gift-tag {
            font-size: 0.8rem;
            color: var(--rose);
        }

        .gift-count {
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            color: var(--rose);
            background: rgba(255, 77, 109, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .sequence-number {
            font-family: 'Roboto', sans-serif;
            /* Changed from Orbitron for readability */
            font-size: 1.2rem;
            /* Slightly smaller to fit better? Or keep large? Let's keep size but change font */
            font-weight: 900;
            /* Extra bold */
            color: var(--secondary);
            width: 90px;
            text-align: right;
            margin-right: 10px;
            letter-spacing: 1px;
        }
    </style>
</head>

<body>
    <h1>ROSE COUNTER</h1>

    <div class="container">
        <div class="controls-row" style="display: flex; flex-wrap: wrap; gap: 1rem;">
            <!-- Box 1: Account -->
            <div class="input-group" style="flex: 2; min-width: 300px; display: flex; flex-direction: column;">
                <div style="display: flex; gap: 8px; align-items: center; width: 100%;">
                    <input type="text" id="username" placeholder="TikTok Username" spellcheck="false"
                        style="padding: 10px 14px; flex: 1;">
                    <button id="connectBtn"
                        style="height: 42px; min-width: 100px; justify-content: center;"><span>CONNECT</span></button>
                </div>
                <div id="statusArea"
                    style="display: flex; align-items: center; gap: 10px; font-size: 0.8rem; margin-top: 8px;">
                    <span id="statusBadge" class="status-badge status-offline">OFFLINE</span>
                    <div id="connectionTarget"
                        style="color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        Not Connected</div>
                </div>
            </div>

            <!-- Box 2: Goal -->
            <div class="input-group" style="flex: 1.5; min-width: 250px; display: flex; flex-direction: column;">
                <div style="display: flex; gap: 8px; align-items: center; width: 100%;">
                    <input type="number" id="targetGoal" placeholder="Goal" value="100"
                        style="padding: 10px 14px; flex: 1;">
                    <button id="setTargetBtn" class="secondary-btn"
                        style="height: 42px; min-width: 100px; justify-content: center;"><span>SET GOAL</span></button>
                </div>
                <div
                    style="font-size: 0.8rem; color: var(--text-dim); margin-top: 8px; display: flex; align-items: center;">
                    <span style="opacity: 0.7;">Target Settings</span>
                </div>
            </div>

            <!-- Box 3: Quit & Reset -->
            <div class="input-group" style="flex: 1; min-width: 180px; display: flex; flex-direction: column;">
                <div style="display: flex; align-items: center; justify-content: center; width: 100%; gap: 5px;">
                    <button id="resetBtn"
                        style="background-color: #555; font-size: 0.7rem; height: 42px; justify-content: center; flex: 1;">
                        <span>‚Üª RESET</span>
                    </button>
                    <button id="quitBtn"
                        style="background-color: #333; font-size: 0.7rem; height: 42px; justify-content: center; flex: 1;">
                        <span>‚ùå QUIT</span>
                    </button>
                </div>
                <div
                    style="font-size: 0.8rem; color: var(--text-dim); text-align: center; margin-top: 8px; display: flex; align-items: center; justify-content: center;">
                    <span style="opacity: 0.7;">Session Controls</span>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <!-- Left Column: Unique Stats + Unique List -->
            <div class="column">
                <div class="stat-card combined-stat">
                    <div class="stat-group">
                        <div class="stat-label">Unique</div>
                        <div id="uniqueCount" class="stat-value unique-value">0</div>
                    </div>
                    <div class="stat-divider">/</div>
                    <div class="stat-group">
                        <div class="stat-label">Remaining</div>
                        <div id="remainingCount" class="stat-value" style="color: var(--primary);">100</div>
                    </div>
                </div>

                <div class="feed-panel">
                    <div class="feed-title" style="justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="color: var(--secondary);">‚ú®</span> UNIQUE LIST
                        </div>
                        <button id="downloadCsvBtn" class="secondary-btn" style="padding: 4px 12px; font-size: 0.8rem;">
                            <span>CSV</span>
                        </button>
                        <button id="copyForSheetsBtn" class="secondary-btn"
                            style="padding: 4px 12px; font-size: 0.8rem; background-color: #0F9D58; color: white;">
                            <span>COPY</span>
                        </button>
                    </div>
                    <div id="uniqueList">
                        <!-- Unique items will appear here -->
                    </div>
                </div>
            </div>

            <!-- Right Column: Total Stats + Live Feed -->
            <div class="column">
                <div class="stat-card">
                    <div class="stat-label">Total Roses</div>
                    <div id="totalCount" class="stat-value total-value">0</div>
                </div>

                <div class="feed-panel">
                    <div class="feed-title">
                        <span>üåπ</span> LIVE FEED
                    </div>
                    <div id="roseFeed">
                        <!-- Rose items will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const connectBtn = document.getElementById('connectBtn');
        const usernameInput = document.getElementById('username');
        const setTargetBtn = document.getElementById('setTargetBtn');
        const targetGoalInput = document.getElementById('targetGoal');
        const statusBadge = document.getElementById('statusBadge');
        const uniqueCountEl = document.getElementById('uniqueCount');
        const totalCountEl = document.getElementById('totalCount');
        const remainingCountEl = document.getElementById('remainingCount');
        const roseFeed = document.getElementById('roseFeed');
        const uniqueList = document.getElementById('uniqueList');
        const downloadCsvBtn = document.getElementById('downloadCsvBtn');
        const copyForSheetsBtn = document.getElementById('copyForSheetsBtn');

        // Create QUIT button dynamically or add to HTML. 
        // Let's add it to the top right or near controls.
        // Actually, let's just add it to the HTML first? 
        // No, I can't edit HTML structure here easily without context of where to put it.
        // Wait, I see "controls-row" in the previous file view around line 355.
        // I'll add the button definition there in a separate edit, 
        // and here I will add the logic.

        // But I need the button element first. 
        // Let's assume I will add <button id="quitBtn" ...> in HTML.
        // So here I add the const and listener.

        const quitBtn = document.getElementById('quitBtn');
        const resetBtn = document.getElementById('resetBtn');

        resetBtn.addEventListener('click', () => {
            if (confirm('„ÄêÊ≥®ÊÑè„Äë\nÁèæÂú®„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü\nÔºà„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅØËá™Âãï„Åß‰øùÂ≠ò„Åï„Çå„Åæ„ÅôÔºâ\n\n‚ÄªÊñ∞„Åó„ÅÑÈÖç‰ø°„ÇíÂßã„ÇÅ„ÇãÊôÇ„Å†„ÅëÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ')) {
                socket.emit('resetSession');
                // Feedback
                alert('„Çª„ÉÉ„Ç∑„Éß„É≥„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü„ÄÇ\nÊñ∞„Åó„ÅÑÈÖç‰ø°„ÇíÈñãÂßã„Åß„Åç„Åæ„Åô„ÄÇ');
            }
        });

        quitBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to quit the application?')) {
                fetch('/shutdown')
                    .then(response => response.text())
                    .then(msg => {
                        document.body.innerHTML = `
                            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh; color:white; font-family:sans-serif;">
                                <h1>${msg}</h1>
                                <p>You can now close this tab.</p>
                            </div>
                        `;
                    })
                    .catch(err => {
                        alert('Error shutting down: ' + err);
                    });
            }
        });

        const connectionTarget = document.getElementById('connectionTarget');

        let isConnectState = true;
        let currentUniqueList = [];

        let retryTimer = null;
        let isWaitingMode = false;

        connectBtn.addEventListener('click', () => {
            if (!isWaitingMode && statusBadge.textContent !== 'CONNECTED') {
                // START Connection logic
                const username = usernameInput.value.trim().replace('@', '');
                if (username) {
                    // UI: Enter "Connecting / Waiting" State
                    connectBtn.innerHTML = '<span>STOP</span>';
                    connectBtn.style.backgroundColor = '#f44336';

                    usernameInput.disabled = true;
                    isWaitingMode = true;

                    attemptConnection(username);
                }
            } else {
                // STOP Logic
                isWaitingMode = false;
                if (retryTimer) {
                    clearTimeout(retryTimer);
                    retryTimer = null;
                }

                socket.emit('disconnectFromLive');

                // Reset UI
                connectBtn.innerHTML = '<span>CONNECT</span>';
                connectBtn.style.backgroundColor = 'var(--primary)';
                connectBtn.disabled = false;
                usernameInput.disabled = false;

                statusBadge.textContent = 'OFFLINE';
                statusBadge.className = 'status-badge status-offline';
                statusBadge.style.backgroundColor = '#444';
                statusBadge.style.color = '#ccc';

                connectionTarget.textContent = 'Not Connected';
                connectionTarget.style.color = 'var(--text-dim)';
            }
        });

        function attemptConnection(username) {
            statusBadge.textContent = 'CONNECTING...';
            statusBadge.className = 'status-badge status-online';
            statusBadge.style.backgroundColor = '#FFC107';
            statusBadge.style.color = 'black';

            connectionTarget.innerHTML = `Connecting to <span style="color: var(--secondary);">@${username}</span>...`;

            socket.emit('connectToLive', username);

            const goal = targetGoalInput.value;
            if (goal) socket.emit('setTarget', goal);

            if (currentUniqueList.length > 0 && !retryTimer) {
                // Only clear if this is a fresh manual click, not a retry
                // logic handled by server mostly
            }
        }

        socket.on('connectionStatus', (data) => {
            // Clear any pending retry
            if (retryTimer) {
                clearTimeout(retryTimer);
                retryTimer = null;
            }

            if (data.status === 'connected') {
                // SUCCESS
                statusBadge.textContent = 'CONNECTED';
                statusBadge.className = 'status-badge status-online';
                statusBadge.style.backgroundColor = '#4caf50';
                statusBadge.style.color = 'white';

                const connectedUser = usernameInput.value.trim().replace('@', '') || 'Unknown';
                connectionTarget.innerHTML = `Connected to <span style="color: var(--secondary); font-weight: bold;">@${connectedUser}</span>`;

                // Keep isWaitingMode = true so "STOP" button works (it means "Active Session")

            } else if (data.status === 'error' || data.status === 'disconnected') {
                // FAILURE / DISCONNECT
                if (isWaitingMode) {
                    // Retry mode active: Schedule retry
                    console.log(`Connection lost/failed: ${data.message}. Retrying...`);

                    let reason = data.message || 'Unknown';
                    let badgeText = 'RETRYING...';
                    let badgeColor = '#FF9800'; // Orange

                    if (reason.includes('User not found')) {
                        reason = 'User Offline';
                        badgeText = 'OFFLINE';
                        badgeColor = '#9E9E9E'; // Grey (Neutral)
                    }
                    if (reason.includes('LIVE has ended')) {
                        reason = 'Stream Ended';
                        badgeText = 'ENDED';
                        badgeColor = '#9E9E9E'; // Grey
                    }

                    statusBadge.textContent = badgeText;
                    statusBadge.style.backgroundColor = badgeColor;

                    // Offline/Ended is neutral, Error/Retry is alert color
                    const isNeutral = (badgeText === 'OFFLINE' || badgeText === 'ENDED');
                    const msgColor = isNeutral ? 'var(--text-dim)' : '#ff7777';

                    connectionTarget.innerHTML = `<span style="color:${msgColor};">${reason}</span> <span style="font-size:0.8em; opacity:0.8;">Retrying in 5s...</span>`;

                    // Schedule next attempt
                    const username = usernameInput.value.trim().replace('@', '');
                    retryTimer = setTimeout(() => {
                        if (isWaitingMode) {
                            attemptConnection(username);
                        }
                    }, 5000);

                } else {
                    // Manual stop or fatal error (shouldn't really happen if mode is off)
                    statusBadge.textContent = 'ERROR';
                    statusBadge.className = 'status-badge status-error';
                    connectionTarget.textContent = data.message;

                    // Reset UI controls
                    connectBtn.innerHTML = '<span>CONNECT</span>';
                    connectBtn.style.backgroundColor = 'var(--primary)';
                    usernameInput.disabled = false;
                }
            } else if (data.status === 'ended') {
                // Stream specifically ended
                // Treat same as error/disconnect for auto-retry (maybe stream restarts?)
                // Or stop? Usually users want to keep waiting.
                // Let's reuse the retry logic above.
                if (isWaitingMode) {
                    statusBadge.textContent = 'ENDED';
                    connectionTarget.innerHTML = `<span style="color:#ff7777;">Stream Ended</span> Retrying...`;
                    const username = usernameInput.value.trim().replace('@', '');
                    retryTimer = setTimeout(() => {
                        if (isWaitingMode) attemptConnection(username);
                    }, 5000);
                }
            }
        });

        setTargetBtn.addEventListener('click', () => {
            const goal = targetGoalInput.value;
            if (goal) {
                socket.emit('setTarget', goal);
                // Visual feedback checkmark or something could be good, but for now simple
                setTargetBtn.innerHTML = '<span>UPDATED!</span>';
                setTimeout(() => {
                    setTargetBtn.innerHTML = '<span>SET GOAL</span>';
                }, 2000);
            }
        });

        // Helper to get Stream Date (handle midnight crossing)
        function getStreamDate() {
            const now = new Date();
            // If before 12:00 PM (noon), assume it belongs to previous day's stream
            if (now.getHours() < 12) {
                now.setDate(now.getDate() - 1);
            }
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        // CSV Download Logic
        downloadCsvBtn.addEventListener('click', () => {
            if (!currentUniqueList || currentUniqueList.length === 0) {
                alert('No data to download.');
                return;
            }

            const streamDate = getStreamDate();
            // CSV Header
            let csvContent = "StreamDate,No.,Nickname,UniqueId\n";

            // CSV Rows
            currentUniqueList.forEach(user => {
                const nickname = user.nickname.replace(/"/g, '""'); // Escape quotes
                csvContent += `${streamDate},${user.sequenceNumber},"${nickname}",${user.uniqueId}\n`;
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.setAttribute("download", `unique_rosers_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Copy for Sheets Logic
        copyForSheetsBtn.addEventListener('click', () => {
            if (!currentUniqueList || currentUniqueList.length === 0) {
                alert('No data to copy.');
                return;
            }

            const streamDate = getStreamDate();
            // TSV Header (Tab Separated)
            let tsvContent = "StreamDate\tNo.\tNickname\tUniqueId\n";

            // TSV Rows
            currentUniqueList.forEach(user => {
                // Sheets handles tabs generally well, but let's be safe with newlines in nicknames if any
                const nickname = user.nickname.replace(/\t/g, ' ').replace(/\n/g, ' ');
                tsvContent += `${streamDate}\t${user.sequenceNumber}\t${nickname}\t${user.uniqueId}\n`;
            });

            navigator.clipboard.writeText(tsvContent).then(() => {
                const originalText = copyForSheetsBtn.querySelector('span').textContent;
                copyForSheetsBtn.querySelector('span').textContent = 'COPIED!';
                setTimeout(() => {
                    copyForSheetsBtn.querySelector('span').textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard.');
            });
        });

        socket.on('connectionStatus', (data) => {
            if (data.status === 'connected') {
                // Success!
                if (retryInterval) {
                    clearInterval(retryInterval);
                    retryInterval = null;
                }

                isConnectState = false;
                connectBtn.innerHTML = '<span>DISCONNECT</span>';
                connectBtn.style.backgroundColor = '#f44336';

                statusBadge.textContent = 'CONNECTED';
                statusBadge.className = 'status-badge status-online';
                statusBadge.style.backgroundColor = '#4caf50';
                statusBadge.style.color = 'white';

                const connectedUser = usernameInput.value.trim().replace('@', '') || 'Unknown';
                connectionTarget.innerHTML = `Connected to <span style="color: var(--secondary); font-weight: bold;">@${connectedUser}</span>`;
                connectionTarget.style.color = 'var(--text)';

            } else if (data.status === 'error') {
                // Keep retrying if in retry mode
                console.log('Connection attempt failed: ' + data.message);
                if (retryInterval) {
                    // Update UI slightly to show we are still trying?
                    // For now, "WAITING..." is sufficient.
                } else {
                    // If we are NOT in retry mode (manual single attempt?), show error
                    // But our new logic always uses retryInterval for "Connect" action.
                    // The only case it's null is if user stopped it.
                }

            } else {
                // Disconnected or Ended
                if (retryInterval) {
                    clearInterval(retryInterval);
                    retryInterval = null;
                }

                isConnectState = true;
                connectBtn.innerHTML = '<span>CONNECT</span>';
                connectBtn.style.backgroundColor = 'var(--primary)';
                usernameInput.disabled = false;

                statusBadge.textContent = data.status.toUpperCase();
                statusBadge.className = 'status-badge status-offline';
                statusBadge.style.backgroundColor = '#444';
                statusBadge.style.color = '#ccc';

                connectionTarget.textContent = 'Not Connected';
                connectionTarget.style.color = 'var(--text-dim)';
            }
        });

        socket.on('targetUpdated', (data) => {
            if (data.uniqueGifterList) {
                currentUniqueList = data.uniqueGifterList;
                renderUniqueList(data.uniqueGifterList);
            }
            // Update remaining calculation only if target changed
            const currentCount = currentUniqueList ? currentUniqueList.length : 0;
            updateRemaining(data.targetGoal, currentCount);
        });

        socket.on('currentState', (data) => {
            uniqueCountEl.textContent = data.uniqueCount;
            totalCountEl.textContent = data.totalCount;

            if (data.uniqueGifterList) {
                currentUniqueList = data.uniqueGifterList;
                renderUniqueList(data.uniqueGifterList);
            }
            updateRemaining(data.targetGoal, data.uniqueCount);
        });

        socket.on('roseUpdate', (data) => {
            uniqueCountEl.textContent = data.uniqueCount;
            totalCountEl.textContent = data.totalCount;

            updateRemaining(data.targetGoal, data.uniqueCount);

            // Live Feed Update
            const item = document.createElement('div');
            item.className = 'rose-item';
            item.innerHTML = `
                <img src="${data.lastGifter.profilePictureUrl}" class="avatar" alt="avatar">
                <div class="user-info">
                    <div class="username">${data.lastGifter.nickname}</div>
                    <div class="gift-tag">sent Roses!</div>
                </div>
                <div class="gift-count">x${data.lastGifter.repeatCount}</div>
            `;
            roseFeed.prepend(item);
            if (roseFeed.children.length > 20) {
                roseFeed.removeChild(roseFeed.lastChild);
            }

            // Unique List Update
            if (data.uniqueGifterList) {
                currentUniqueList = data.uniqueGifterList;
                renderUniqueList(data.uniqueGifterList);
            }
        });

        function updateRemaining(goal, current) {
            const rem = Math.max(0, goal - current);
            remainingCountEl.textContent = rem;
            if (rem === 0) {
                remainingCountEl.textContent = "GOAL!";
                remainingCountEl.style.color = "var(--secondary)";
            } else {
                remainingCountEl.style.color = "var(--primary)";
            }
        }

        function renderUniqueList(list) {
            uniqueList.innerHTML = '';
            const reversedList = [...list].reverse();

            reversedList.forEach(user => {
                const item = document.createElement('div');
                item.className = 'unique-item';
                const paddedNumber = String(user.sequenceNumber).padStart(3, '0');
                item.innerHTML = `
                    <div class="sequence-number">No.${paddedNumber}</div>
                    <img src="${user.profilePictureUrl}" class="avatar" alt="avatar">
                    <div class="user-info">
                        <div class="username">${user.nickname}</div>
                        <div class="user-id">@${user.uniqueId}</div>
                    </div>
                `;
                uniqueList.appendChild(item);
            });
        }
    </script>
</body>

</html>